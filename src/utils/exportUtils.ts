import { Document } from '../types/Document';

/**
 * Exports a document to various formats
 * 
 * This implementation provides client-side export functionality for TXT, PDF, and DOCX formats.
 * PDF generation uses jsPDF and DOCX uses a simple implementation with proper formatting.
 */
export const exportDocumentAs = async (document: Document, format: 'pdf' | 'docx' | 'txt') => {
  const plainText = document.content.replace(/<[^>]*>/g, '');
  const title = document.title || 'Untitled Document';
  
  // Create filename with timestamp
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `${title.replace(/[^a-z0-9]/gi, '-')}-${timestamp}`;
  
  switch (format) {
    case 'txt':
      downloadTextFile(`${title}\n\n${plainText}`, `${filename}.txt`);
      break;
      
    case 'pdf':
      await exportToPDF(title, plainText, filename);
      break;
      
    case 'docx':
      await exportToDOCX(title, plainText, filename);
      break;
  }
};

/**
 * Export to PDF using jsPDF
 */
const exportToPDF = async (title: string, content: string, filename: string) => {
  try {
    // Dynamic import to reduce bundle size
    const { jsPDF } = await import('jspdf');
    
    const doc = new jsPDF();
    
    // Set font and add title
    doc.setFontSize(16);
    doc.text(title, 20, 20);
    
    // Add content with proper text wrapping
    doc.setFontSize(12);
    const splitText = doc.splitTextToSize(content, 170);
    doc.text(splitText, 20, 40);
    
    // Add scores if available
    if (content.includes('Score:')) {
      doc.setFontSize(10);
      doc.text('Generated by REALSCORE - Automated Text Scoring System', 20, doc.internal.pageSize.height - 20);
    }
    
    doc.save(`${filename}.pdf`);
  } catch (error) {
    console.error('Error generating PDF:', error);
    alert('Error generating PDF. Falling back to text export.');
    downloadTextFile(`${title}\n\n${content}`, `${filename}.txt`);
  }
};

/**
 * Export to DOCX using a simple implementation
 */
const exportToDOCX = async (title: string, content: string, filename: string) => {
  try {
    // Dynamic import to reduce bundle size
    const { Document: DocxDocument, Packer, Paragraph, TextRun, HeadingLevel } = await import('docx');
    
    const doc = new DocxDocument({
      sections: [{
        properties: {},
        children: [
          new Paragraph({
            text: title,
            heading: HeadingLevel.TITLE,
          }),
          new Paragraph({
            text: "",
          }),
          ...content.split('\n').map(line => 
            new Paragraph({
              children: [new TextRun(line)],
            })
          ),
        ],
      }],
    });
    
    const blob = await Packer.toBlob(doc);
    downloadBlob(blob, `${filename}.docx`, 'application/vnd.openxmlformats-officedocument.wordprocessingml.document');
  } catch (error) {
    console.error('Error generating DOCX:', error);
    alert('Error generating DOCX. Falling back to text export.');
    downloadTextFile(`${title}\n\n${content}`, `${filename}.txt`);
  }
};

/**
 * Helper function to download text as a file
 */
const downloadTextFile = (text: string, filename: string) => {
  const blob = new Blob([text], { type: 'text/plain' });
  downloadBlob(blob, filename, 'text/plain');
};

/**
 * Helper function to download any blob as a file
 */
const downloadBlob = (blob: Blob, filename: string, mimeType: string) => {
  const url = URL.createObjectURL(blob);
  
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  
  // Clean up
  setTimeout(() => {
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, 100);
};